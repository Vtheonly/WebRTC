/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var F = Object.defineProperty;
var J = Object.getOwnPropertyDescriptor;
var X = Object.getOwnPropertyNames;
var Z = Object.prototype.hasOwnProperty;
var ee = (u, p) => {
    for (var e in p) F(u, e, { get: p[e], enumerable: !0 });
  },
  te = (u, p, e, t) => {
    if ((p && typeof p == "object") || typeof p == "function")
      for (let n of X(p))
        !Z.call(u, n) &&
          n !== e &&
          F(u, n, {
            get: () => p[n],
            enumerable: !(t = J(p, n)) || t.enumerable,
          });
    return u;
  };
var se = (u) => te(F({}, "__esModule", { value: !0 }), u);
var ce = {};
ee(ce, { default: () => R });
module.exports = se(ce);
var A = require("obsidian");
var x = require("obsidian");
function B(u) {
  let p = `Generate test questions based on the following notes.

`;
  return (
    u.forEach((e) => {
      (p += `### Note: ${e.filePath}
`),
        (p += `Content:
${e.content}

`);
    }),
    (p +=
      "Ensure that the test questions are relevant to the content and test key concepts."),
    p
  );
}
var ne = "https://api.openai.com/v1/chat/completions",
  re = "https://api.anthropic.com/v1/messages",
  ie = "https://api.deepseek.com/v1/chat/completions";
var oe = "https://api.mistral.ai/v1/chat/completions",
  k = class extends Error {
    constructor(p) {
      super(p), (this.name = "ContextLengthExceededError");
    }
  };
function G(u, p) {
  return p[u] || "";
}
async function _(u, p, e, t) {
  let n = G(p, e),
    s = (t == null ? void 0 : t[p]) || K(p);
  if (!n)
    throw new Error(
      `Missing API key for ${p}! Please set it in the plugin settings.`
    );
  let r = B(u),
    d = `
You are a helpful AI that generates test questions from user study notes.
We want each question to end with "(1)", "(2)", or "(3)" to show how many marks it is worth.
Correspondingly, the "type" field is "short" (1 mark), "long" (2 marks), or "extended" (3 marks).

Generate 5 test questions based on the notes provided. // <--- ADDED INSTRUCTION NUMBER OF QUestions

Return JSON in this shape (no extra keys, no markdown fences):
{
  "description": string,
  "questions": [
    { "question": "What is X? (1)", "type": "short" },
    { "question": "Explain Y in detail. (2)", "type": "long" },
    { "question": "Discuss Z thoroughly with examples. (3)", "type": "extended" }
    // You can leave the example as 3, the explicit instruction takes precedence.
  ]
}
`.trim();
  try {
    let o;
    switch (p) {
      case "openai":
        o = await V(d, r, n, s);
        break;
      case "anthropic":
        o = await z(d, r, n, s);
        break;
      case "deepseek":
        o = await Q(d, r, n, s);
        break;
      case "gemini":
        o = await U(d, r, n, s);
        break;
      case "mistral":
        o = await Y(d, r, n, s);
        break;
      default:
        throw new Error(`Unsupported provider: ${p}`);
    }
    return ae(o);
  } catch (o) {
    throw o instanceof k
      ? o
      : o instanceof Error &&
        (o.message.includes("context_length_exceeded") ||
          o.message.includes("maximum context length"))
      ? new k(
          "The document is too large for the model's context window. Please split your document into smaller sections."
        )
      : o;
  }
}
async function O(u, p, e, t, n) {
  let s = G(e, t),
    r = (n == null ? void 0 : n[e]) || K(e);
  if (!s)
    throw new Error(
      `Missing API key for ${e}! Please set it in the plugin settings.`
    );
  let d = `
You are a helpful AI that grades user answers based on the provided source text.
A question might have (1), (2), or (3) to indicate mark weighting. For each answer, you need to return:
  - questionNumber: The question number (starting from 1)
  - marks: How many marks earned (0 to maxMarks)
  - maxMarks: Maximum possible marks for this question (1, 2, or 3)
  - feedback: A brief explanation of the grading

Output must be a JSON array with these fields only.
`.trim(),
    o = `SOURCE DOCUMENT:
${u}

USER ANSWERS:
`;
  p.forEach((i, a) => {
    let h = 1,
      l = i.question.match(/\((\d)\)\s*$/);
    l && [1, 2, 3].includes(parseInt(l[1], 10))
      ? (h = parseInt(l[1], 10))
      : i.type === "long"
      ? (h = 2)
      : i.type === "extended" && (h = 3),
      (o += `Q${a + 1} (maxMarks=${h}): ${i.question}
Answer: ${i.answer || "[No answer provided]"}

`);
  }),
    (o += `Please return a JSON array of objects, each with { "questionNumber", "marks", "maxMarks", "feedback" }. 
Marks should reflect the quality of the answer (0 = no credit, maxMarks = full credit, with partial marks possible).
No extra fields, no markdown code blocks.`);
  try {
    let i;
    switch (e) {
      case "openai":
        i = await V(d, o, s, r, 1e3);
        break;
      case "anthropic":
        i = await z(d, o, s, r, 1e3);
        break;
      case "deepseek":
        i = await Q(d, o, s, r, 1e3);
        break;
      case "gemini":
        i = await U(d, o, s, r, 1e3);
        break;
      case "mistral":
        i = await Y(d, o, s, r, 1e3);
        break;
      default:
        throw new Error(`Unsupported provider: ${e}`);
    }
    return le(i);
  } catch (i) {
    throw i instanceof k
      ? i
      : i instanceof Error &&
        (i.message.includes("context_length_exceeded") ||
          i.message.includes("maximum context length"))
      ? new k(
          "The document is too large for the model's context window. Please split your document into smaller sections."
        )
      : i;
  }
}
function K(u) {
  switch (u) {
    case "openai":
      return "gpt-4";
    case "anthropic":
      return "claude-3-opus-20240229";
    case "deepseek":
      return "deepseek-chat";
    case "gemini":
      // return "gemini-pro";
      return "gemini-2.5-pro-exp-03-25"; // New default fallback

    case "mistral":
      return "mistral-medium";
    default:
      return "";
  }
}
function ae(u) {
  if (!u) throw new Error("No content from LLM for test questions.");
  let p = u.trim();
  p.startsWith("```json") && (p = p.slice(7).trim()),
    p.endsWith("```") && (p = p.slice(0, -3).trim());
  let e = p.lastIndexOf("}");
  e !== -1 && (p = p.slice(0, e + 1)), p.endsWith("}") || (p += "}");
  try {
    return JSON.parse(p);
  } catch (t) {
    throw new Error("Failed to parse JSON response for test questions");
  }
}
function le(u) {
  if (!u) throw new Error("No marking feedback returned by LLM.");
  (u = u.trim()),
    u.startsWith("```") &&
      (u = u
        .replace(/^```[a-z]*\n?/, "")
        .replace(/```$/, "")
        .trim());
  try {
    return JSON.parse(u);
  } catch (p) {
    throw new Error("Failed to parse LLM marking JSON output.");
  }
}
async function V(u, p, e, t = "gpt-4", n = 1000) {
  var o, i, a, h, l;
  let s = {
      model: t,
      messages: [
        { role: "system", content: u },
        { role: "user", content: p },
      ],
      temperature: 0.7,
      max_tokens: n,
    },
    r = await fetch(ne, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${e}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(s),
    });
  if (!r.ok) {
    let c = await r.json();
    throw ((o = c.error) == null ? void 0 : o.code) ===
      "context_length_exceeded"
      ? new k(
          `The document is too large for ${t}'s context window. Please split your document into smaller sections.`
        )
      : new Error(
          `OpenAI API Error: ${r.status} - ${
            ((i = c.error) == null ? void 0 : i.message) || r.statusText
          }`
        );
  }
  return (
    ((l =
      (h = (a = (await r.json()).choices) == null ? void 0 : a[0]) == null
        ? void 0
        : h.message) == null
      ? void 0
      : l.content) || ""
  );
}
async function z(u, p, e, t = "claude-3-opus-20240229", n = 500) {
  var o, i, a, h, l, c;
  let s = {
      model: t,
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `${u}

${p}`,
            },
          ],
        },
      ],
      max_tokens: n,
    },
    r = await fetch(re, {
      method: "POST",
      headers: {
        "x-api-key": e,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json",
      },
      body: JSON.stringify(s),
    });
  if (!r.ok) {
    let g = await r.json();
    throw ((o = g.error) == null ? void 0 : o.type) ===
      "context_length_exceeded" ||
      ((a = (i = g.error) == null ? void 0 : i.message) != null &&
        a.includes("context window"))
      ? new k(
          `The document is too large for ${t}'s context window. Please split your document into smaller sections.`
        )
      : new Error(
          `Anthropic API Error: ${r.status} - ${
            ((h = g.error) == null ? void 0 : h.message) || r.statusText
          }`
        );
  }
  return (
    ((c = (l = (await r.json()).content) == null ? void 0 : l[0]) == null
      ? void 0
      : c.text) || ""
  );
}
async function Q(u, p, e, t = "deepseek-chat", n = 500) {
  var o, i, a, h, l, c, g;
  let s = {
      model: t,
      messages: [
        { role: "system", content: u },
        { role: "user", content: p },
      ],
      max_tokens: n,
    },
    r = await fetch(ie, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${e}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(s),
    });
  if (!r.ok) {
    let f = await r.json();
    throw ((o = f.error) == null ? void 0 : o.code) ===
      "context_window_exceeded" ||
      ((a = (i = f.error) == null ? void 0 : i.message) != null &&
        a.includes("context length"))
      ? new k(
          `The document is too large for ${t}'s context window. Please split your document into smaller sections.`
        )
      : new Error(
          `DeepSeek API Error: ${r.status} - ${
            ((h = f.error) == null ? void 0 : h.message) || r.statusText
          }`
        );
  }
  return (
    ((g =
      (c = (l = (await r.json()).choices) == null ? void 0 : l[0]) == null
        ? void 0
        : c.message) == null
      ? void 0
      : g.content) || ""
  );
}
async function U(u, p, e, t = "gemini-pro", n = 500) {
  var h, l, c, g, f, m, y, w, P, E;
  let s = `${u}

${p}`,
    d = `https://generativelanguage.googleapis.com/v1beta/models/${
      t === "gemini-pro" ? "gemini-pro" : t
    }:generateContent?key=${e}`,
    i = await fetch(d, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ parts: [{ text: s }] }],
        generationConfig: { maxOutputTokens: n, temperature: 0.7 },
      }),
    });
  if (!i.ok) {
    let N = await i.json();
    throw ((l = (h = N.error) == null ? void 0 : h.message) != null &&
      l.includes("context length")) ||
      ((g = (c = N.error) == null ? void 0 : c.message) != null &&
        g.includes("token limit"))
      ? new k(
          `The document is too large for ${t}'s context window. Please split your document into smaller sections.`
        )
      : new Error(
          `Google Gemini API Error: ${i.status} - ${
            ((f = N.error) == null ? void 0 : f.message) || i.statusText
          }`
        );
  }
  return (
    ((E =
      (P =
        (w =
          (y = (m = (await i.json()).candidates) == null ? void 0 : m[0]) ==
          null
            ? void 0
            : y.content) == null
          ? void 0
          : w.parts) == null
        ? void 0
        : P[0]) == null
      ? void 0
      : E.text) || ""
  );
}
async function Y(u, p, e, t = "mistral-medium", n = 500) {
  var o, i, a, h, l, c, g, f, m;
  let s = {
      model: t,
      messages: [
        { role: "system", content: u },
        { role: "user", content: p },
      ],
      temperature: 0.7,
      max_tokens: n,
    },
    r = await fetch(oe, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${e}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(s),
    });
  if (!r.ok) {
    let y = await r.json();
    throw ((o = y.error) == null ? void 0 : o.type) ===
      "context_length_exceeded" ||
      ((a = (i = y.error) == null ? void 0 : i.message) != null &&
        a.includes("context")) ||
      ((l = (h = y.error) == null ? void 0 : h.message) != null &&
        l.includes("token limit"))
      ? new k(
          `The document is too large for ${t}'s context window. Please split your document into smaller sections.`
        )
      : new Error(
          `Mistral API Error: ${r.status} - ${
            ((c = y.error) == null ? void 0 : c.message) || r.statusText
          }`
        );
  }
  return (
    ((m =
      (f = (g = (await r.json()).choices) == null ? void 0 : g[0]) == null
        ? void 0
        : f.message) == null
      ? void 0
      : m.content) || ""
  );
}
var M = "rag-test-view",
  D = class extends x.ItemView {
    constructor(e, t, n, s) {
      super(e);
      this.isRefreshing = !1;
      this.fileTreeRoot = {
        name: "root",
        path: "",
        isFolder: !0,
        children: [],
      };
      this.expandedFolders = new Set();
      (this.pluginData = n), (this.plugin = s), this.buildFileTree();
    }
    getViewType() {
      return M;
    }
    getDisplayText() {
      return "Test Dashboard";
    }
    async onOpen() {
      !this.pluginData || this.pluginData.length === 0
        ? this.handleRefresh()
        : this.render();
    }
    showFullPageSpinner(e) {
      let n = this.containerEl.createDiv({ cls: "loading-container" });
      (n.style.position = "fixed"),
        (n.style.top = "0"),
        (n.style.left = "0"),
        (n.style.width = "100%"),
        (n.style.height = "100%"),
        (n.style.zIndex = "1000"),
        (n.style.display = "flex"),
        (n.style.justifyContent = "center"),
        (n.style.alignItems = "center"),
        (n.style.backgroundColor = "rgba(0, 0, 0, 0.5)");
      let s = n.createDiv({ cls: "loading-container" });
      return (
        s.createDiv({ cls: "spinner" }),
        s.createEl("p", { text: e, cls: "loading-text" }),
        n
      );
    }
    hideFullPageSpinner(e) {
      e && e.remove();
    }
    async cleanupStaleTestDocuments() {
      let e = this.plugin;
      if (!e) return 0;
      let t = new Set(e.indexedNotes.map((s) => s.filePath)),
        n = [];
      return (
        Object.keys(e.testDocuments).forEach((s) => {
          t.has(s) || n.push(s);
        }),
        n.length > 0 &&
          (n.forEach((s) => {
            delete e.testDocuments[s];
          }),
          await e.saveSettings()),
        n.length
      );
    }
    async onClose() {}
    buildFileTree() {
      (this.fileTreeRoot = {
        name: "root",
        path: "",
        isFolder: !0,
        children: [],
      }),
        this.pluginData.forEach((e) => {
          let t = e.filePath.split("/"),
            n = this.fileTreeRoot,
            s = "";
          for (let d = 0; d < t.length - 1; d++) {
            let o = t[d];
            s = s ? `${s}/${o}` : o;
            let i = n.children.find((a) => a.isFolder && a.name === o);
            i ||
              ((i = {
                name: o,
                path: s,
                isFolder: !0,
                children: [],
                expanded: this.expandedFolders.has(s),
              }),
              n.children.push(i)),
              (n = i);
          }
          let r = t[t.length - 1];
          n.children.push({
            name: r,
            path: e.filePath,
            isFolder: !1,
            children: [],
            note: e,
          });
        }),
        this.sortFileTree(this.fileTreeRoot);
    }
    sortFileTree(e) {
      e.children.sort((t, n) =>
        t.isFolder && !n.isFolder
          ? -1
          : !t.isFolder && n.isFolder
          ? 1
          : t.name.localeCompare(n.name)
      ),
        e.children.forEach((t) => {
          t.isFolder && this.sortFileTree(t);
        });
    }
    async render() {
      let e = this.containerEl;
      if ((e.empty(), e.addClass("test-dashboard-container"), !this.plugin)) {
        e.createEl("div", {
          cls: "empty-state",
          text: "Test Plugin not found.",
        });
        return;
      }
      let n = e.createEl("div", { cls: "dashboard-header" });
      n.createEl("h2", { text: "Test Dashboard", cls: "dashboard-title" });
      let s = n.createEl("div", { cls: "dashboard-actions" }),
        r = s.createEl("button", {
          cls: "dashboard-button secondary",
          attr: { title: "Refresh file index" },
        });
      this.isRefreshing
        ? (r.createDiv({ cls: "spinner" }),
          r.createSpan({ text: " Refreshing..." }))
        : (r.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-refresh-cw">
          <polyline points="23 4 23 10 17 10"></polyline>
          <polyline points="1 20 1 14 7 14"></polyline>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
        </svg>
        <span>Refresh</span>
      `),
        (r.disabled = this.isRefreshing),
        (r.onclick = () => this.handleRefresh());
      let d = s.createEl("button", {
        text: "Create Tests",
        cls: "dashboard-button primary",
      });
      (d.disabled = !0), (d.onclick = () => this.createTests());
      let o = e.createEl("div", { cls: "file-tree-container" });
      if (!this.pluginData || this.pluginData.length === 0) {
        o.createEl("div", {
          cls: "empty-state",
          text: "No files found. Click Refresh to scan your vault.",
        });
        return;
      }
      this.buildFileTree(),
        this.renderFileTree(o, this.fileTreeRoot, d),
        this.updateCreateBtn(d);
      let a = e
          .createEl("div", { cls: "mark-all-container" })
          .createEl("button", {
            cls: "dashboard-button primary mark-all-button",
            text: "Mark All Tests",
          }),
        h = Object.entries(this.plugin.testDocuments).some(
          ([l, c]) =>
            c.answers &&
            Object.values(c.answers).some((g) => g && g.trim().length > 0) &&
            typeof c.score != "number"
        );
      (a.disabled = !h), (a.onclick = () => this.markAllTests());
    }
    renderFileTree(e, t, n, s = 0) {
      if (t === this.fileTreeRoot) {
        let d = e.createEl("div", { cls: "file-tree" });
        t.children.forEach((o) => {
          this.renderFileTree(d, o, n, s);
        });
        return;
      }
      let r = e.createEl("div", { cls: "file-tree-item" });
      if (((r.style.paddingLeft = `${s * 20}px`), t.isFolder)) {
        let d = r.createEl("div", { cls: "folder-row" }),
          o = d.createEl("div", {
            cls: `folder-toggle ${t.expanded ? "expanded" : "collapsed"}`,
          });
        o.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" 
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="${
            t.expanded ? "6 9 12 15 18 9" : "9 18 15 12 9 6"
          }"></polyline>
        </svg>
      `;
        let i = d.createEl("span", { cls: "folder-icon" });
        if (
          ((i.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" 
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
        </svg>
      `),
          d.createEl("span", { text: t.name, cls: "folder-name" }),
          (d.onclick = (a) => {
            (t.expanded = !t.expanded),
              t.expanded
                ? this.expandedFolders.add(t.path)
                : this.expandedFolders.delete(t.path),
              this.render(),
              a.stopPropagation();
          }),
          t.expanded)
        ) {
          let a = r.createEl("div", { cls: "folder-children" });
          t.children.forEach((h) => {
            this.renderFileTree(a, h, n, s + 1);
          });
        }
      } else {
        let d = r.createEl("div", { cls: "file-row" }),
          o = d.createEl("input", { type: "checkbox", cls: "file-checkbox" });
        o.dataset.filePath = t.path;
        let i = d.createEl("span", { cls: "file-icon" });
        (i.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" 
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
      `),
          d.createEl("span", { text: t.name, cls: "file-name" });
        let a = this.plugin.testDocuments[t.path],
          h = d.createEl("span", { cls: "status-icon" });
        if (a)
          if (typeof a.score == "number") {
            let l = a.score,
              c = l >= 80 ? "complete" : "partial",
              g = h.createEl("button", {
                attr: { title: "Open Test Document" },
              }),
              f = g.createEl("div", { cls: `status-badge ${c}` }),
              m = Math.round(l),
              y = 8,
              w = 2 * Math.PI * y,
              P = w * (1 - m / 100);
            (f.innerHTML = `
          <svg class="progress-ring" width="18" height="18" viewBox="0 0 24 24">
            <circle class="progress-ring-circle" cx="12" cy="12" r="${y}"/>
            <circle class="progress-ring-progress" 
              cx="12" cy="12" r="${y}"
              stroke="${l >= 80 ? "#22c55e" : "#f59e0b"}"
              stroke-dasharray="${w} ${w}"
              stroke-dashoffset="${P}"/>
          </svg>
          <span>${m}%</span>
        `),
              (g.onclick = (E) => {
                this.plugin.openQuestionDoc(t.path), E.stopPropagation();
              });
          } else {
            let l = a.questions.length,
              c = Object.values(a.answers || {}).filter((w) => w.trim()).length,
              g = Math.round((c / l) * 100),
              f = c === 0 ? "none" : c === l ? "complete" : "in-progress",
              m = h.createEl("button", {
                attr: { title: "Open Test Document" },
              }),
              y = m.createEl("div", { cls: `status-badge ${f}` });
            if (c === 0)
              y.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="badge-icon">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="16" y1="13" x2="8" y2="13"></line>
              <line x1="16" y1="17" x2="8" y2="17"></line>
              <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
            <span>Start</span>
          `;
            else {
              let P = 2 * Math.PI * 8,
                E = P * (1 - g / 100);
              y.innerHTML = `
            <svg class="progress-ring" width="18" height="18" viewBox="0 0 24 24">
              <circle class="progress-ring-circle" cx="12" cy="12" r="${8}"/>
              <circle class="progress-ring-progress" 
                cx="12" cy="12" r="${8}"
                stroke="#f59e0b"
                stroke-dasharray="${P} ${P}"
                stroke-dashoffset="${E}"/>
            </svg>
            <span>${c}/${l}</span>
          `;
            }
            m.onclick = (w) => {
              this.plugin.openQuestionDoc(t.path), w.stopPropagation();
            };
          }
        else {
          let l = h.createEl("div", { cls: "status-badge none" });
          l.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="badge-icon">
            <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
            <polyline points="13 2 13 9 20 9"></polyline>
          </svg>
          <span>No Tests</span>
        `;
        }
        o.onchange = () => this.updateCreateBtn(n);
      }
    }
    updateCreateBtn(e) {
      let t = this.containerEl.querySelectorAll('input[type="checkbox"]');
      e.disabled = !Array.from(t).some((n) => n.checked);
    }
    async handleRefresh() {
      if (!this.isRefreshing)
        try {
          (this.isRefreshing = !0),
            this.render(),
            new x.Notice("\u{1F504} Refreshing test index...");
          let e = await this.plugin.indexTestNotes();
          this.pluginData = e;
          let t = await this.cleanupStaleTestDocuments();
          this.render(),
            t > 0
              ? new x.Notice(
                  `\u2705 Indexed ${e.length} notes and removed ${t} stale test documents.`
                )
              : new x.Notice(`\u2705 Indexed ${e.length} notes.`);
        } catch (e) {
          console.error("Error refreshing index:", e),
            new x.Notice(
              "\u274C Error refreshing index. Check console for details."
            );
        } finally {
          (this.isRefreshing = !1), this.render();
        }
    }
    async createTests() {
      let e = this.plugin;
      if (!e) {
        new x.Notice("\u274C Test Plugin not found.");
        return;
      }
      let t = e.settings.llmProvider;
      if (!e.settings.apiKeys[t]) {
        new x.Notice(
          `\u274C ${this.getProviderDisplayName(
            t
          )} API Key is missing! Please set it in the plugin settings.`
        );
        return;
      }
      let s = this.containerEl.querySelectorAll('input[type="checkbox"]'),
        r = [];
      await this.cleanupStaleTestDocuments();
      for (let d of Array.from(s)) {
        let o = d;
        if (o.checked) {
          let i = o.dataset.filePath;
          if (!i) continue;
          let a = this.pluginData.find((c) => c.filePath === i);
          if (!a) continue;
          let h = o.closest(".file-row"),
            l = h == null ? void 0 : h.querySelector(".status-icon");
          l && (l.innerHTML = '<div class="spinner"></div>'),
            r.push(
              (async () => {
                try {
                  let c = await _(
                    [a],
                    e.settings.llmProvider,
                    e.settings.apiKeys,
                    e.settings.models
                  );
                  if (
                    ((e.testDocuments[i] = {
                      description: c.description,
                      questions: c.questions,
                      answers: {},
                    }),
                    await e.saveSettings(),
                    l)
                  ) {
                    let g = document.createElement("button");
                    g.title = "Open Test Document";
                    let f = document.createElement("div");
                    (f.className = "status-badge none"),
                      (f.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="badge-icon">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                  <polyline points="14 2 14 8 20 8"></polyline>
                  <line x1="16" y1="13" x2="8" y2="13"></line>
                  <line x1="16" y1="17" x2="8" y2="17"></line>
                  <polyline points="10 9 9 9 8 9"></polyline>
                </svg>
                <span>Start</span>
              `),
                      g.appendChild(f),
                      (l.innerHTML = ""),
                      l.appendChild(g),
                      (g.onclick = (m) => {
                        e.openQuestionDoc(i), m.stopPropagation();
                      });
                  }
                } catch (c) {
                  if ((console.error("Error generating tests:", c), l)) {
                    let g = document.createElement("div");
                    (g.className = "status-badge none"),
                      (g.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="badge-icon">
                  <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
                  <polyline points="13 2 13 9 20 9"></polyline>
                </svg>
                <span>No Tests</span>
              `),
                      (l.innerHTML = ""),
                      l.appendChild(g);
                  }
                  c instanceof k
                    ? new x.Notice(`\u274C ${i}: ${c.message}`, 1e4)
                    : new x.Notice(`\u274C Error generating tests for ${i}`);
                }
              })()
            );
        }
      }
      try {
        await Promise.all(r),
          new x.Notice("\u2705 Test generation complete!"),
          s.forEach((o) => {
            o.checked = !1;
          });
        let d = this.containerEl.querySelector(".dashboard-button.primary");
        d && (d.disabled = !0);
      } catch (d) {
        console.error("Error in test generation:", d),
          new x.Notice(
            "\u274C Some tests could not be generated. Check console for details."
          );
      }
    }
    getProviderDisplayName(e) {
      switch (e) {
        case "openai":
          return "OpenAI";
        case "anthropic":
          return "Claude";
        case "deepseek":
          return "DeepSeek";
        case "gemini":
          return "Gemini";
        case "mistral":
          return "Mistral";
        default:
          return e.charAt(0).toUpperCase() + e.slice(1);
      }
    }
    async markAllTests() {
      let e = this.plugin;
      if (!e) {
        new x.Notice("\u274C Test Plugin not found.");
        return;
      }
      let t = e.settings.llmProvider,
        n = e.settings.apiKeys;
      if (!n[t]) {
        new x.Notice(
          `\u274C ${this.getProviderDisplayName(
            t
          )} API Key is missing! Please set it in the plugin settings.`
        );
        return;
      }
      await this.cleanupStaleTestDocuments();
      let s = [],
        r = [];
      if (
        (Object.entries(e.testDocuments).forEach(([l, c]) => {
          c.answers &&
            Object.values(c.answers).some((f) => f && f.trim().length > 0) &&
            (typeof c.score == "number" ? r.push(l) : s.push(l));
        }),
        s.length === 0)
      ) {
        r.length > 0
          ? new x.Notice(
              `\u2705 All tests with answers (${r.length}) are already marked.`
            )
          : new x.Notice("No tests with answers to mark.");
        return;
      }
      let d = [],
        o = [];
      for (let l of s)
        e.indexedNotes.find((g) => g.filePath === l) ? d.push(l) : o.push(l);
      if (o.length > 0) {
        new x.Notice(
          "There's an issue with the test index. Please restart Obsidian and try again.",
          8e3
        );
        return;
      }
      if (d.length === 0) {
        r.length > 0
          ? new x.Notice(
              `\u2705 All valid tests (${r.length}) are already marked.`
            )
          : new x.Notice("No valid tests with answers found.");
        return;
      }
      let a = this.containerEl.createDiv({ cls: "loading-container" });
      (a.style.position = "fixed"),
        (a.style.top = "0"),
        (a.style.left = "0"),
        (a.style.width = "100%"),
        (a.style.height = "100%"),
        (a.style.zIndex = "1000"),
        (a.style.display = "flex"),
        (a.style.justifyContent = "center"),
        (a.style.alignItems = "center"),
        (a.style.backgroundColor = "rgba(0, 0, 0, 0.5)");
      let h = a.createDiv({ cls: "loading-container" });
      h.createDiv({ cls: "spinner" }),
        h.createEl("p", {
          text: `Marking ${d.length} tests using ${this.getProviderDisplayName(
            t
          )}... This may take a few moments.`,
          cls: "loading-text",
        });
      try {
        let l = d.map(async (m) => {
            try {
              let y = e.indexedNotes.find((v) => v.filePath === m);
              if (!y)
                return {
                  filePath: m,
                  success: !1,
                  error: "Note content not found",
                };
              let w = e.testDocuments[m],
                P = y.content,
                E = w.questions.map((v, C) => ({
                  question: v.question,
                  answer: w.answers[C] || "",
                  type: v.type,
                }));
              if (!E.some((v) => v.answer.trim()))
                return {
                  filePath: m,
                  success: !1,
                  error: "No answers to mark",
                };
              let N = await O(P, E, t, n, this.plugin.settings.models),
                $ = 0,
                q = 0,
                H = new Array(w.questions.length).fill(null);
              N.forEach((v) => {
                let C = v.questionNumber - 1;
                C >= 0 &&
                  C < w.questions.length &&
                  ((H[C] = {
                    marks: v.marks,
                    maxMarks: v.maxMarks,
                    feedback: v.feedback,
                  }),
                  ($ += v.maxMarks),
                  (q += v.marks));
              });
              let j = $ ? (q / $) * 100 : 0;
              return (
                (e.testDocuments[m] = {
                  ...e.testDocuments[m],
                  score: j,
                  markResults: H,
                }),
                {
                  filePath: m,
                  success: !0,
                  score: j,
                  earnedMarks: q,
                  possibleMarks: $,
                }
              );
            } catch (y) {
              return (
                console.error(`Error marking test ${m}:`, y),
                {
                  filePath: m,
                  success: !1,
                  error: y.message || "Unknown error",
                }
              );
            }
          }),
          c = await Promise.all(l);
        await e.saveSettings(), this.render();
        let g = c.filter((m) => m.success).length,
          f = c.length - g;
        f > 0
          ? new x.Notice(
              `\u2705 Marked ${g} tests successfully. \u274C ${f} tests failed.`
            )
          : new x.Notice(
              `\u2705 Successfully marked all ${g} tests with ${this.getProviderDisplayName(
                t
              )}!`
            );
      } catch (l) {
        console.error("Error in markAllTests:", l),
          new x.Notice(
            `\u274C Error marking tests with ${this.getProviderDisplayName(
              t
            )}. Check console for details.`
          );
      } finally {
        a && a.remove();
      }
    }
  };
var T = require("obsidian");
var S = "question-document-view",
  I = class extends T.ItemView {
    constructor(e, t, n, s) {
      super(e);
      this.generatedTests = [];
      this.answers = {};
      this.markResults = [];
      this.scoreSummary = "";
      (this.app = t),
        (this.plugin = n),
        (this.description = s.description),
        (this.generatedTests = s.questions),
        (this.filePath = "");
    }
    getViewType() {
      return S;
    }
    getDisplayText() {
      return this.filePath
        ? `Test: ${this.filePath}`
        : "Generated Test Questions";
    }
    async onOpen() {
      this.render();
    }
    async onClose() {}
    showSpinner() {
      let e =
          this.containerEl.querySelector(".test-document-container") ||
          this.containerEl,
        t = e.createDiv({ cls: "spinner-overlay-question" }),
        n = Math.max(e.scrollHeight || 0);
      (t.style.position = "absolute"),
        (t.style.top = "0"),
        (t.style.left = "0"),
        (t.style.width = "100%"),
        (t.style.height = n + "px"),
        (t.style.zIndex = "1000");
      let s = t.createDiv({ cls: "spinner-fixed" });
      return (
        (s.style.position = "fixed"),
        (s.style.top = "50%"),
        (s.style.left = "50%"),
        (s.style.transform = "translate(-50%, -50%)"),
        (s.style.zIndex = "1001"),
        (s.style.textAlign = "center"),
        s.createDiv({ cls: "spinner" }),
        s.createEl("p", {
          text: "Marking in progress...",
          cls: "loading-text",
        }),
        t
      );
    }
    hideSpinner(e) {
      e.remove();
    }
    render() {
      var d;
      let e = this.containerEl;
      if (
        (e.empty(),
        (e.style.position = "relative"),
        e.addClass("test-document-container"),
        (e.style.overflowY = "auto"),
        (e.style.maxHeight = "calc(100vh - 100px)"),
        !((d = this.generatedTests) != null && d.length))
      ) {
        e.createEl("p", { text: "No test questions available." });
        return;
      }
      e.createEl("p", { text: this.description, cls: "test-description" });
      let t = e.createEl("form");
      (t.style.overflowY = "visible"),
        this.generatedTests.forEach((o, i) => {
          let a = t.createEl("div", { cls: "question-item" }),
            h = a.createEl("label", { cls: "question-label" });
          h.createSpan({ cls: "question-number", text: `${i + 1}` }),
            h.createSpan({ text: o.question });
          let l = a.createEl("textarea", {
            cls: "answer-input",
            attr: { placeholder: "Type your answer here", rows: "3" },
          });
          this.answers[i] && (l.value = this.answers[i]);
          let c = this.markResults[i];
          if (c) {
            let m = (c.marks / c.maxMarks) * 100;
            m >= 80
              ? l.addClass("correct")
              : m > 0
              ? l.addClass("partial")
              : l.addClass("incorrect");
          }
          let g = () => {
            (l.style.height = "auto"), (l.style.height = l.scrollHeight + "px");
          };
          setTimeout(g, 0),
            l.addEventListener("input", () => {
              (this.answers[i] = l.value), this.saveAnswers(), g();
            });
          let f = a.createEl("div", { cls: "feedback" });
          if (c) {
            f.createEl("div", {
              cls: "marks-display",
              text: `${c.marks}/${c.maxMarks} marks`,
            });
            let m = (c.marks / c.maxMarks) * 100;
            m >= 80
              ? f.addClass("correct")
              : m > 0
              ? f.addClass("partial")
              : f.addClass("incorrect"),
              f.addClass("visible"),
              f.createEl("div", { cls: "feedback-text", text: c.feedback });
          }
        });
      let n = t.createEl("div", { cls: "test-document-actions" }),
        s = n.createEl("button", {
          text: "Mark",
          cls: "test-button mark-button",
        });
      (s.type = "button"), (s.onclick = () => this.handleMarkButtonClick());
      let r = n.createEl("button", {
        text: "Reset",
        cls: "test-button reset-button",
      });
      (r.type = "button"),
        (r.onclick = () => this.handleResetButtonClick()),
        this.scoreSummary &&
          t.createEl("div", { text: this.scoreSummary, cls: "score-summary" }),
        e.appendChild(t);
    }
    async handleMarkButtonClick() {
      if (!this.filePath) {
        new T.Notice("No file path found for this test document.");
        return;
      }
      let e = this.plugin.indexedNotes.find(
        (i) => i.filePath === this.filePath
      );
      if (!e) {
        new T.Notice(
          "No indexed content found for this file. Cannot mark answers."
        );
        return;
      }
      let t = this.plugin.settings.llmProvider,
        n = this.plugin.settings.apiKeys;
      if (!n[t]) {
        new T.Notice(
          `${this.getProviderDisplayName(
            t
          )} API key missing. Please set it in plugin settings.`
        );
        return;
      }
      let s = e.content,
        r = this.generatedTests.map((i, a) => ({
          question: i.question,
          answer: this.answers[a] || "",
          type: i.type,
        })),
        d = this.showSpinner(),
        o = window.setInterval(() => {
          let i =
              this.containerEl.querySelector(".test-document-container") ||
              this.containerEl,
            a = Math.max(i.scrollHeight || 0);
          d.style.height = a + "px";
        }, 200);
      new T.Notice(
        `Marking in progress using ${this.getProviderDisplayName(t)}...`
      );
      try {
        let i = await O(s, r, t, n, this.plugin.settings.models);
        (this.markResults = new Array(this.generatedTests.length).fill(null)),
          i.forEach((c) => {
            let g = c.questionNumber - 1;
            g >= 0 &&
              g < this.generatedTests.length &&
              (this.markResults[g] = {
                marks: c.marks,
                maxMarks: c.maxMarks,
                feedback: c.feedback,
              });
          });
        let a = 0,
          h = 0;
        for (let c = 0; c < this.markResults.length; c++) {
          let g = this.markResults[c];
          g && ((a += g.maxMarks), (h += g.marks));
        }
        let l = a ? ((h / a) * 100).toFixed(1) : "0.0";
        (this.scoreSummary = `You scored ${h} / ${a} marks (${l}%)`),
          this.plugin.testDocuments[this.filePath] ||
            (this.plugin.testDocuments[this.filePath] = {
              description: this.description,
              questions: this.generatedTests,
              answers: {},
            }),
          (this.plugin.testDocuments[this.filePath] = {
            ...this.plugin.testDocuments[this.filePath],
            score: parseFloat(l),
            markResults: this.markResults,
            answers: this.answers,
          }),
          await this.plugin.saveSettings(),
          this.plugin.markFileAnswered(this.filePath),
          this.render(),
          new T.Notice("Marking complete!");
      } catch (i) {
        if ((console.error("Error marking answers:", i), i instanceof k)) {
          new T.Notice(`\u274C Context Length Error: ${i.message}`, 1e4);
          let a = this.containerEl.createDiv({ cls: "error-message" });
          a.createEl("h3", {
            text: `Document Too Large for ${this.getProviderDisplayName(t)}`,
          }),
            a.createEl("p", { text: i.message }),
            a.createEl("p", {
              cls: "suggestion",
              text: "Suggestions: Split your document into smaller parts, or try a different LLM provider with a larger context window.",
            }),
            this.render();
        } else
          new T.Notice(
            `Error marking answers with ${this.getProviderDisplayName(
              t
            )}. Check console for details.`
          );
      } finally {
        window.clearInterval(o), this.hideSpinner(d);
      }
    }
    getProviderDisplayName(e) {
      switch (e) {
        case "openai":
          return "OpenAI";
        case "anthropic":
          return "Claude";
        case "deepseek":
          return "DeepSeek";
        case "gemini":
          return "Gemini";
        case "mistral":
          return "Mistral";
        default:
          return e.charAt(0).toUpperCase() + e.slice(1);
      }
    }
    handleResetButtonClick() {
      (this.answers = {}),
        (this.markResults = []),
        (this.scoreSummary = ""),
        this.filePath &&
          (this.plugin.testDocuments[this.filePath]
            ? (this.plugin.testDocuments[this.filePath].answers = {})
            : (this.plugin.testDocuments[this.filePath] = {
                description: this.description,
                questions: this.generatedTests,
                answers: {},
              }),
          delete this.plugin.testDocuments[this.filePath].score,
          this.plugin.saveSettings(),
          this.plugin.markFileAnswered(this.filePath),
          this.render());
    }
    saveAnswers() {
      this.filePath &&
        (this.plugin.testDocuments[this.filePath] ||
          (this.plugin.testDocuments[this.filePath] = {
            description: this.description,
            questions: this.generatedTests,
            answers: {},
          }),
        (this.plugin.testDocuments[this.filePath].answers = this.answers),
        this.plugin.saveSettings(),
        this.plugin.markFileAnswered(this.filePath));
    }
  };
var b = require("obsidian"),
  L = class extends b.PluginSettingTab {
    constructor(e, t) {
      super(e, t);
      this.plugin = t;
    }
    display() {
      let { containerEl: e } = this;
      e.empty(),
        e.createEl("h2", { text: "RAG Test Plugin Settings" }),
        new b.Setting(e)
          .setName("LLM Provider")
          .setDesc(
            "Select which LLM provider you want to use for generating and marking tests"
          )
          .addDropdown((s) => {
            s.addOption("openai", "OpenAI")
              .addOption("anthropic", "Anthropic (Claude)")
              .addOption("deepseek", "DeepSeek")
              .addOption("gemini", "Google (Gemini)")
              // <-- ADD THIS LINE: Add the new model to the dropdown options
              .addOption(
                "gemini-2.5-pro-exp-03-25",
                "Gemini 2.5 Pro Experimental"
              )
              // <-- CHANGE THIS LINE: Update the fallback value if settings.models.gemini is missing
              // .setValue(this.plugin.settings.models.gemini || "gemini-pro") // Old fallback
              .setValue(
                this.plugin.settings.models.gemini || "gemini-2.5-pro-exp-03-25"
              ) // New fallback

              .addOption("mistral", "Mistral AI")
              .setValue(this.plugin.settings.llmProvider)
              .onChange(async (r) => {
                (this.plugin.settings.llmProvider = r),
                  await this.plugin.saveSettings(),
                  this.display();
              });
          }),
        this.plugin.settings.llmProvider === "openai" &&
          (new b.Setting(e)
            .setName("OpenAI API Key")
            .setDesc(
              "Enter your OpenAI API key for test generation and marking"
            )
            .addText((s) =>
              s
                .setPlaceholder("sk-...")
                .setValue(this.plugin.settings.apiKeys.openai)
                .onChange(async (r) => {
                  (this.plugin.settings.apiKeys.openai = r),
                    await this.plugin.saveSettings();
                })
            ),
          new b.Setting(e)
            .setName("OpenAI Model")
            .setDesc("Select which OpenAI model to use")
            .addDropdown((s) => {
              s.addOption("gpt-3.5-turbo", "GPT-3.5 Turbo")
                .addOption("gpt-4", "GPT-4")
                .addOption("gpt-4-turbo", "GPT-4 Turbo")
                .addOption("gpt-4o", "GPT-4o")
                .setValue(this.plugin.settings.models.openai || "gpt-4")
                .onChange(async (r) => {
                  (this.plugin.settings.models.openai = r),
                    await this.plugin.saveSettings();
                });
            })),
        this.plugin.settings.llmProvider === "anthropic" &&
          (new b.Setting(e)
            .setName("Anthropic Claude API Key")
            .setDesc("Enter your Anthropic API key for Claude")
            .addText((s) =>
              s
                .setPlaceholder("sk-ant-...")
                .setValue(this.plugin.settings.apiKeys.anthropic)
                .onChange(async (r) => {
                  (this.plugin.settings.apiKeys.anthropic = r),
                    await this.plugin.saveSettings();
                })
            ),
          new b.Setting(e)
            .setName("Claude Model")
            .setDesc("Select which Claude model to use")
            .addDropdown((s) => {
              s.addOption("claude-3-opus-20240229", "Claude 3 Opus")
                .addOption("claude-3-sonnet-20240229", "Claude 3 Sonnet")
                .addOption("claude-3-haiku-20240307", "Claude 3 Haiku")
                .addOption("claude-3-5-sonnet-20240620", "Claude 3.5 Sonnet")
                .setValue(
                  this.plugin.settings.models.anthropic ||
                    "claude-3-opus-20240229"
                )
                .onChange(async (r) => {
                  (this.plugin.settings.models.anthropic = r),
                    await this.plugin.saveSettings();
                });
            })),
        this.plugin.settings.llmProvider === "deepseek" &&
          (new b.Setting(e)
            .setName("DeepSeek API Key")
            .setDesc("Enter your DeepSeek API key")
            .addText((s) =>
              s
                .setPlaceholder("sk-...")
                .setValue(this.plugin.settings.apiKeys.deepseek)
                .onChange(async (r) => {
                  (this.plugin.settings.apiKeys.deepseek = r),
                    await this.plugin.saveSettings();
                })
            ),
          new b.Setting(e)
            .setName("DeepSeek Model")
            .setDesc("Select which DeepSeek model to use")
            .addDropdown((s) => {
              s.addOption("deepseek-chat", "DeepSeek Chat")
                .addOption("deepseek-coder", "DeepSeek Coder")
                .setValue(
                  this.plugin.settings.models.deepseek || "deepseek-chat"
                )
                .onChange(async (r) => {
                  (this.plugin.settings.models.deepseek = r),
                    await this.plugin.saveSettings();
                });
            })),
        this.plugin.settings.llmProvider === "gemini" &&
          (new b.Setting(e)
            .setName("Google Gemini API Key")
            .setDesc("Enter your Google API key for Gemini")
            .addText((s) =>
              s
                .setPlaceholder("API key...")
                .setValue(this.plugin.settings.apiKeys.gemini)
                .onChange(async (r) => {
                  (this.plugin.settings.apiKeys.gemini = r),
                    await this.plugin.saveSettings();
                })
            ),
          new b.Setting(e)
            .setName("Gemini Model")
            .setDesc("Select which Gemini model to use")
            .addDropdown((s) => {
              s.addOption("gemini-pro", "Gemini Pro")
                .addOption("gemini-1.5-pro", "Gemini 1.5 Pro")
                .addOption("gemini-1.5-flash", "Gemini 1.5 Flash")
                .setValue(this.plugin.settings.models.gemini || "gemini-pro")
                .onChange(async (r) => {
                  (this.plugin.settings.models.gemini = r),
                    await this.plugin.saveSettings();
                });
            })),
        this.plugin.settings.llmProvider === "mistral" &&
          (new b.Setting(e)
            .setName("Mistral API Key")
            .setDesc("Enter your Mistral API key")
            .addText((s) =>
              s
                .setPlaceholder("...")
                .setValue(this.plugin.settings.apiKeys.mistral)
                .onChange(async (r) => {
                  (this.plugin.settings.apiKeys.mistral = r),
                    await this.plugin.saveSettings();
                })
            ),
          new b.Setting(e)
            .setName("Mistral Model")
            .setDesc("Select which Mistral model to use")
            .addDropdown((s) => {
              s.addOption("mistral-tiny", "Mistral Tiny")
                .addOption("mistral-small", "Mistral Small")
                .addOption("mistral-medium", "Mistral Medium")
                .addOption("mistral-large-latest", "Mistral Large (Latest)")
                .setValue(
                  this.plugin.settings.models.mistral || "mistral-medium"
                )
                .onChange(async (r) => {
                  (this.plugin.settings.models.mistral = r),
                    await this.plugin.saveSettings();
                });
            })),
        e.createEl("h3", { text: "About API Keys" }),
        e.createDiv({ cls: "api-key-info" }).createEl("p", {
          text: "Your API keys are stored locally in your vault and are only used to communicate with the selected LLM provider.",
        });
      let n = e.createDiv({ cls: "provider-info" });
      this.plugin.settings.llmProvider === "openai"
        ? (n.createEl("p", {
            text: "OpenAI API keys can be obtained from: https://platform.openai.com/account/api-keys",
          }),
          n.createEl("p", {
            text: "GPT-4 and GPT-4o provide the best results but require a higher API usage tier.",
          }))
        : this.plugin.settings.llmProvider === "anthropic"
        ? (n.createEl("p", {
            text: "Anthropic API keys can be obtained from: https://console.anthropic.com/settings/keys",
          }),
          n.createEl("p", {
            text: "Claude models excel at understanding context and providing helpful feedback. Claude 3 Opus has the largest context window.",
          }))
        : this.plugin.settings.llmProvider === "deepseek"
        ? n.createEl("p", {
            text: "DeepSeek API keys can be obtained from the DeepSeek website.",
          })
        : this.plugin.settings.llmProvider === "gemini"
        ? (n.createEl("p", {
            text: "Google Gemini API keys can be obtained from Google AI Studio: https://makersuite.google.com/app/apikey",
          }),
          n.createEl("p", {
            text: "Gemini 1.5 Pro offers a larger context window and improved capabilities over Gemini Pro.",
          }))
        : this.plugin.settings.llmProvider === "mistral" &&
          (n.createEl("p", {
            text: "Mistral API keys can be obtained from: https://console.mistral.ai/api-keys/",
          }),
          n.createEl("p", {
            text: "Mistral offers several model sizes with different capabilities and pricing. Mistral Medium provides a good balance of performance and cost.",
          }));
    }
  };
var W = {
    mySetting: "default",
    llmProvider: "openai",
    apiKeys: {
      openai: "",
      anthropic: "",
      deepseek: "",
      gemini: "",
      mistral: "",
    },
    models: {
      openai: "gpt-4",
      anthropic: "claude-3-opus-20240229",
      deepseek: "deepseek-chat",
      // gemini: "gemini-pro",

      gemini: "gemini-2.5-pro-exp-03-25", // New default

      mistral: "mistral-medium",
    },
  },
  R = class extends A.Plugin {
    constructor() {
      super(...arguments);
      this.indexedNotes = [];
      this.testDocuments = {};
      this.stylesLoaded = !1;
    }
    async onload() {
      this.loadStyles(),
        await this.loadSettings(),
        this.registerView(
          M,
          (e) => new D(e, this.app, this.indexedNotes, this)
        ),
        this.registerView(
          S,
          (e) => new I(e, this.app, this, { description: "", questions: [] })
        ),
        this.addRibbonIcon("flask-conical", "Test Dashboard", () =>
          this.openTestDashboard()
        ),
        this.addStatusBarItem().setText("Test Plugin Active"),
        this.addCommand({
          id: "open-test-dashboard",
          name: "Open Test Dashboard",
          callback: () => {
            this.openTestDashboard();
          },
        }),
        this.addSettingTab(new L(this.app, this)),
        this.registerInterval(window.setInterval(() => {}, 5 * 60 * 1e3));
    }
    onunload() {
      let e = document.getElementById("obsidian-test-plugin-styles");
      e && e.remove(),
        this.app.workspace.detachLeavesOfType(M),
        this.app.workspace.detachLeavesOfType(S);
    }
    loadStyles() {
      if (
        this.stylesLoaded ||
        document.getElementById("obsidian-test-plugin-styles")
      )
        return;
      let e = document.createElement("style");
      (e.id = "obsidian-test-plugin-styles"),
        (e.textContent = `
/* Common Styles for Test Plugin */
.test-dashboard-container,
.test-document-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: var(--font-text, inherit);
}

/* Dashboard Specific Styles */
.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--background-modifier-border);
}

.dashboard-title {
  margin: 0;
  font-size: 1.5em;
  font-weight: bold;
  color: var(--text-normal);
}

.dashboard-actions {
  display: flex;
  gap: 8px;
}

.file-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.file-item {
  display: flex;
  align-items: center;
  padding: 10px;
  margin-bottom: 8px;
  border-radius: 6px;
  background-color: var(--background-secondary);
  transition: background-color 0.2s ease;
}

.file-item:hover {
  background-color: var(--background-secondary-alt);
}

.file-checkbox {
  margin-right: 10px;
}

.file-path {
  flex: 1;
  margin-right: 10px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.status-icon button {
  background: none;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  padding: 4px 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.status-icon button:hover {
  background-color: var(--background-modifier-hover);
}

.status-badge {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-on-accent);
  min-width: 60px;
  transition: all 0.2s ease;
}

.status-badge.none {
  background-color: var(--background-modifier-border);
  color: var(--text-muted);
}

.status-badge.in-progress {
  background-color: #f59e0b; /* Amber color */
  color: #fff;
}

.status-badge.partial {
  background: linear-gradient(90deg, #f59e0b 50%, #84cc16 50%);
  color: #fff;
}

.status-badge.complete {
  background-color: #22c55e; /* Green color */
  color: #fff;
}

.badge-icon {
  margin-right: 6px;
}

.progress-ring {
  transform: rotate(-90deg);
  transform-origin: 50% 50%;
  margin-right: 6px;
}

.progress-ring-circle {
  stroke: var(--background-primary);
  stroke-width: 2;
  fill: transparent;
}

.progress-ring-progress {
  stroke-linecap: round;
  stroke-width: 2;
  fill: transparent;
  transition: stroke-dashoffset 0.3s ease;
}

.dashboard-button,
.test-button {
  padding: 6px 12px;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.1s;
  border: none;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.dashboard-button:hover,
.test-button:hover {
  transform: translateY(-1px);
}

.dashboard-button:active,
.test-button:active {
  transform: translateY(1px);
}

.dashboard-button.primary,
.mark-button {
  background-color: var(--interactive-accent);
  color: var(--text-on-accent);
}

.dashboard-button.primary:hover,
.mark-button:hover {
  background-color: var(--interactive-accent-hover);
}

.dashboard-button.secondary,
.reset-button {
  background-color: var(--background-modifier-border);
  color: var(--text-normal);
}

.dashboard-button.secondary:hover,
.reset-button:hover {
  background-color: var(--background-modifier-border-hover);
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-muted);
}

/* Question Document View Styles */
.test-description {
  font-style: italic;
  margin-bottom: 2em;
  color: var(--text-muted);
  border-left: 3px solid var(--interactive-accent);
  padding-left: 10px;
  line-height: 1.5;
}

.question-item {
  margin-bottom: 2em;
  padding: 16px;
  border-radius: 8px;
  background-color: var(--background-secondary);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: box-shadow 0.3s ease;
}

.question-item:hover {
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
}

.question-label {
  display: block;
  font-weight: bold;
  margin-bottom: 0.8em;
  font-size: 1.1em;
}

.question-number {
  display: inline-block;
  background-color: var(--interactive-accent);
  color: var(--text-on-accent);
  width: 24px;
  height: 24px;
  text-align: center;
  border-radius: 50%;
  margin-right: 8px;
  font-size: 0.9em;
  line-height: 24px;
}

.answer-input {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background-color: var(--background-primary);
  font-family: inherit;
  transition: border 0.2s ease;
  min-height: 60px;
  resize: vertical;
  line-height: 1.5;
  overflow-y: hidden;
}

.answer-input:focus {
  border-color: var(--interactive-accent);
  outline: none;
  box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

.answer-input.correct {
  border: 2px solid #4caf50;
  background-color: rgba(76, 175, 80, 0.05);
}

.answer-input.incorrect {
  border: 2px solid #f44336;
  background-color: rgba(244, 67, 54, 0.05);
}

.feedback {
  margin-top: 0.5em;
  font-weight: 500;
  border-radius: 4px;
  padding: 6px 10px;
  font-size: 0.9em;
  display: none;
}

.feedback.visible {
  display: block;
}

.feedback.correct {
  color: #2e7d32;
  background-color: rgba(76, 175, 80, 0.1);
}

.feedback.incorrect {
  color: #c62828;
  background-color: rgba(244, 67, 54, 0.1);
}

.test-document-actions {
  margin-top: 2em;
  display: flex;
  justify-content: center;
  gap: 1em;
}

.score-summary {
  margin-top: 2em;
  padding: 12px;
  border-radius: 6px;
  font-weight: bold;
  text-align: center;
  font-size: 1.1em;
  background-color: var(--background-primary-alt);
  border: 1px solid var(--background-modifier-border);
}

.spinner-overlay-question {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  pointer-events: all;
}

.spinner-fixed {
  position: fixed;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  border-radius: 10px;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: var(--interactive-accent);
  animation: spin 1s linear infinite;
  margin: 0 auto;
}

.loading-text {
  margin-top: 16px;
  color: white;
  font-size: 16px;
  font-weight: 500;
  text-align: center;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.error-message {
  background-color: rgba(220, 38, 38, 0.1);
  color: #dc2626;
  padding: 12px 16px;
  margin-bottom: 20px;
  border-radius: 6px;
  border: 1px solid #dc2626;
  position: relative;
}

.error-message h3 {
  margin: 0 0 8px 0;
  color: #dc2626;
  font-size: 1.1em;
  font-weight: 600;
}

.error-message p {
  margin: 0 0 8px 0;
  font-size: 0.95em;
}

.error-message p:last-child {
  margin-bottom: 0;
}

.error-message .suggestion {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(220, 38, 38, 0.3);
  font-style: italic;
}

/* Partial mark styling */
.answer-input.partial {
  border: 2px solid #f59e0b;
  background-color: rgba(245, 158, 11, 0.05);
}

.feedback.partial {
  color: #92400e;
  background-color: rgba(245, 158, 11, 0.1);
}

/* Marks display styling */
.marks-display {
  font-weight: 600;
  margin-bottom: 6px;
  padding: 2px 8px;
  display: inline-block;
  border-radius: 4px;
}

.feedback.correct .marks-display {
  background-color: rgba(76, 175, 80, 0.2);
}

.feedback.partial .marks-display {
  background-color: rgba(245, 158, 11, 0.2);
}

.feedback.incorrect .marks-display {
  background-color: rgba(244, 67, 54, 0.2);
}

.feedback-text {
  margin-top: 4px;
}

.file-tree-container {
  margin-top: 16px;
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  border-radius: 8px;
  background-color: var(--background-secondary);
}

.file-tree {
  padding: 8px 0;
}

.file-tree-item {
  overflow: hidden;
}

.folder-row, 
.file-row {
  display: flex;
  align-items: center;
  padding: 6px 10px;
  border-radius: 4px;
  margin: 2px 8px;
  transition: background-color 0.2s ease;
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.folder-row:hover,
.file-row:hover {
  background-color: var(--background-modifier-hover);
}

.folder-toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  margin-right: 4px;
  color: var(--text-muted);
  transition: transform 0.2s ease;
}

.folder-toggle.expanded svg {
  transform: rotate(0deg);
}

.folder-toggle.collapsed svg {
  transform: rotate(-90deg);
}

.folder-icon, 
.file-icon {
  display: flex;
  align-items: center;
  margin-right: 8px;
  color: var(--text-muted);
}

.folder-name, 
.file-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-checkbox {
  margin-right: 8px;
}

.file-row .status-badge {
  font-size: 11px;
  padding: 2px 6px;
  margin-left: 8px;
  min-width: 50px;
  display: flex;
  align-items: center;
}

.file-row .badge-icon {
  width: 12px;
  height: 12px;
}

.folder-row.active {
  background-color: var(--background-modifier-active-hover);
  font-weight: 600;
}

.folder-children {
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0.5; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.mark-all-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 10;
}

.mark-all-button {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  transition: all 0.2s ease;
  border-radius: 6px;
}

.mark-all-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.mark-all-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  background-color: var(--background-primary);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.mark-all-button .spinner {
  width: 14px;
  height: 14px;
}
`),
        document.head.appendChild(e),
        (this.stylesLoaded = !0);
    }
    async loadSettings() {
      let e = await this.loadData();
      e
        ? ((this.settings = Object.assign({}, W, e.settings)),
          (this.indexedNotes = e.persistedIndex || []),
          (this.testDocuments = e.testDocuments || {}))
        : ((this.settings = W),
          (this.indexedNotes = []),
          (this.testDocuments = {}));
    }
    async saveSettings() {
      let e = {
        settings: this.settings,
        persistedIndex: this.indexedNotes,
        testDocuments: this.testDocuments,
      };
      await this.saveData(e);
    }
    async indexTestNotes() {
      this.indexedNotes = [];
      let e = this.app.vault.getFiles();
      for (let n of e) {
        if (!n.path.endsWith(".md")) continue;
        let s = await this.app.vault.read(n);
        this.indexedNotes.push({
          filePath: n.path,
          content: s,
          testStatus: { testsReady: !0, passed: 0, total: 0 },
        });
      }
      await this.saveSettings();
      let t = this.app.workspace.getLeavesOfType(M)[0];
      return (
        (t == null ? void 0 : t.view) instanceof D &&
          ((t.view.pluginData = this.indexedNotes), t.view.render()),
        new A.Notice(`Indexed ${this.indexedNotes.length} notes`),
        this.indexedNotes
      );
    }
    openTestDashboard() {
      this.app.workspace.detachLeavesOfType(M);
      let e = this.app.workspace.getLeftLeaf(!1);
      if (!e) {
        new A.Notice("Could not obtain workspace leaf.");
        return;
      }
      e.setViewState({ type: M, active: !0 }), this.app.workspace.revealLeaf(e);
    }
    markFileAnswered(e) {
      let t = this.app.workspace.getLeavesOfType("rag-test-view")[0];
      (t == null ? void 0 : t.view) instanceof D && t.view.render();
    }
    openQuestionDoc(e) {
      if (!this.testDocuments[e]) {
        new A.Notice("No tests found for this note. Generate tests first.");
        return;
      }
      let t = this.testDocuments[e];
      this.app.workspace.detachLeavesOfType(S);
      let n = this.app.workspace.getLeaf("tab");
      n.setViewState({ type: S, active: !0 }),
        this.app.workspace.revealLeaf(n),
        setTimeout(() => {
          let s = n.view;
          if (s) {
            if (
              ((s.filePath = e),
              (s.description = t.description),
              (s.generatedTests = t.questions),
              (s.answers = t.answers || {}),
              t.markResults &&
                t.markResults.length > 0 &&
                ((s.markResults = t.markResults), typeof t.score == "number"))
            ) {
              let r = t.markResults || [],
                d = 0,
                o = 0;
              r.forEach((i) => {
                i && ((d += i.marks), (o += i.maxMarks));
              }),
                (s.scoreSummary = `You scored ${d} / ${o} marks (${t.score.toFixed(
                  1
                )}%)`);
            }
            s.render();
          }
        }, 200);
    }
  };

/* nosourcemap */
